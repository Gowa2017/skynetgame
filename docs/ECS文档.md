# 云风的分享
[2017-06-20 浅谈《守望先锋》中的 ECS 构架](https://blog.codingnow.com/2017/06/overwatch_ecs.html)
[2018-11-30 ECS 中的 Entity](https://blog.codingnow.com/2018/11/ecs_entity.html)
[2019-01-18 最近对 ECS 框架的一些想法](https://blog.codingnow.com/2019/02/ecs_system.html)
[2019-01-24 跟踪对 Component 的修改](https://blog.codingnow.com/2019/02/component_modify.html)
[2019-12-24 ECS 中的消息发布订阅机制](https://blog.codingnow.com/2019/12/ecs_message_matching.html)
[2020-02-13 ECS 中的概念缺失](https://blog.codingnow.com/2020/01/ecs_policy.html)
[2020-02-19 不适合使用 System 的一种情况](https://blog.codingnow.com/2020/01/skeleton_system.html)

--------------
[2021-06-11 带猜测的二分查找算法](https://blog.codingnow.com/2021/06/binary_search_by_guess.html)
[2021-07-19 ECS 模型下的处理模式](https://blog.codingnow.com/2021/07/lua_ecs.html)
[2021-07-27 Tag set 的数据结构优化](https://blog.codingnow.com/2021/07/tag_set.html)
[2021-11-12 ECS 中同类关联数据的处理](https://blog.codingnow.com/2021/11/related_components.html)

# Wikipedia 上的介绍

ECS 是一个软件架构模式，大多用来在视频游戏开发中存储游戏世界的对象。一个 ECS 符合 数据的 **组件** 组成了 **实体**。

ECS 遵守在继承之上组合的规则，这意味着每个实体不是通过一个 **类型** 来定义，而是通过它所关联的 **组件** 来定义。 **组件** 如何与 **实体** 相关依赖于 ECS 系统如何使用。

## 特点

ECS 的数据布局可能不同，**组件** 的定义也可能不同，**组件** 如何与 **实体** 关联也可能不同。

Unity 游戏引擎实现了两种最流行的布局：

- 在 Unity 中最常用的布局中有一个实体叫做 *gameObjects*，每个 *gameObjects* 有一系列的组件。
- 另外一个数据布局和数据库相似，常在 Web 开发中看到。这种布局有很多表，每个表的列是多个组件。在系统中，一个实体的 *类型* 基于它所拥有的组件。对于每个实体 *类型*，有一个表（叫做 *archetype*）的列是一系列的组件，这些组件与实体使用的组件相匹配。为了访问一个具体的实体，首先必须先找到正确的 *archetype*（表），然后索引某一列来获取那个实体对于的每一个组件。

在一个数据库风格的 ECS 中，被叫做 **系统** 的过程在有特定组件的实体上进行动作。

例如，对于一个物理系统可能会查询有 mass, velocity 和 position 组件的 *archetypes* （表），遍历列，然后在每个实体的组件上进行物理计算。

实体的行为在运行时可能会被系统添加、删除或改变（mutate，改变状态）组件而变化。这可避免了在 OOP 中过深和过宽的继承类层次的所产生的难以理解、维护和扩展的问题。通常 ECS 方式高度与 DOD（data-oriented design) 技术相兼容，且常在一起配合使用。尽管一个实体与其组件相关联，但这些组件在物理内存中并不一定需要挨在一起。

## 讨论

Adam Martin 的一系列博客定义了它所认为的 ECS 应该是怎么样的：

- Entity，实体：一个通用的对象。通常，它只会由一个唯一的 ID 组成。"他们将每个 gameObject 标记为一个独立的 Item"。实现通常会使用一个整型。
- Component，组件：对象的一个方面的原始数据及对象如何与世界交互。“给实体打上标签并处理这些特定的方面”。实现上通常会使用 结构体、类或关联数组。
- System，系统：每个系统会持续运行（尽管每个系统有它自己的私有线程）并每个满足系统要求的实体上的一个或多个组件上进行全局动作。

## Martins ECS

一个实体只有 ID，用来访问组件。在组件内没有代码（行为）。组件并不需要物理上在一起，但应该是很容易的通过实体就能访问和查询。常用的实践是为实体使用一个唯一的ID。这不是一个强制需求，但它有几个优点：

- 实体可以通过ID而不是指针引用。这更健壮，允许实体被销毁而不留下野指针。
- 这对在外部存在状态有用。当状态再次加载时，不需要将指针进行重新构造。
- 数据可以在内存中动来动去。
- 实体ID可以在网络中唯一的表示一个实体。

某些优点也可以通过智能指针来实现

## Apparatus ECS


Apparatus 是一个 Unreal Engine 的第三方的 ECS 实现，在常规的 ECS 模式上引入了一些额外的特性。其中之一就是支持组件的 **类层次**。每个组件可以有一个组件类型（或一个基类），就像和 OOP 中的差不多。一个系统就可以通过这个基类进行查询，并获取到此基类衍生的所有子类的实体。这在需要进行一些通用的逻辑是很有用。


## 数据库风格的ECS模式

在系统间传递数据的方式是将数据存储在组件中，接着让各系统访问这个组件。如，，对象的位置可能被更新了。然后其他系统可能会使用这个位置。如果，有很多不同的不常见的事件，那组件中可能就需要很多的 `标志`。然后系统就必须在遍历中监控这些标志，这会变得效率低下。一个方式是使用 **观察者模式**。所有依赖事件的系统会订阅这个事件。因此，从事件来的动作只需要在发生的时候执行一次，而不需要进行轮询。

ECS 架构不会遇到 OOP 中的依赖问题，因为组件只是简单的数据，没有依赖。每个系统通常会查询实体必须拥有的由组件组成的 *archetype` 。例如，一个渲染系统可能会注册 模型，变换和绘制组件。然后会在实体上查询这些组件，如果实体上有这些组件，就执行逻辑；没有这些组件，就跳过。然而，这里可能也会隐藏BUG，因为从一个系统到另外一个系统通过组件来传递值是很难DEBUG的。ECS 可能被用于在非耦合数据需要绑定到一个给定生命周期的情况。

ECS 使用组合，而不是继承树。一个实体典型的是由一个ID，和一系列的组件组成。任何类型的游戏对象都可以通过添加正确的组件到实体上来建立。这也允许开发者很容易的对某个类型的对象添加特性而不需要担心依赖问题。例如，一个玩家实体可能会有一个 *bullet* 组件，它可能就满足被某些 *bulletHanlder* 操纵的要求。


